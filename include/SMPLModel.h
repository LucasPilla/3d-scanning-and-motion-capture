// SMPLModel.h
// ----------
// Interface for the SMPL (Skinned Multi-Person Linear) parametric body model.

#pragma once

#include <Eigen/Dense>
#include <string>
#include <vector>

// A simple mesh container for SMPL output.
struct SMPLMesh
{
    // size: numVertices, positions in world or model space
    std::vector<Eigen::Vector3f> vertices;

    // size: numFaces, triangle vertex indices
    std::vector<Eigen::Vector3i> faces;

    // Saves the mesh to OBJ format
    bool save(const std::string &path) const;
};

class SMPLModel
{
private:
    using MatrixXd = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>;
    using MatrixXi = Eigen::Matrix<int, Eigen::Dynamic, Eigen::Dynamic>;

    // --------- Model data (loaded from JSON) ---------

    // (numVertices, 3)
    MatrixXd templateVertices_;

    // (numFaces, 3) triangle indices
    MatrixXi faces_;

    // Shape blendshapes, flattened as (numVertices * 3, numShapeCoeffs)
    MatrixXd shapeBlendShapes_;

    // Pose blendshapes, flattened as (numVertices * 3, numPoseCoeffs)
    MatrixXd poseBlendShapes_;

    // Joint regressor: (numJoints, numVertices)
    MatrixXd jointRegressor_;

    // Weights: (numVertices, numJoints)
    MatrixXd weights_;

    // Kinematic Tree: (2, numJoints)
    MatrixXi kinematicTree_;

    // --------- SMPL parameters ---------
    Eigen::VectorXd poseParams_ = Eigen::VectorXd::Zero(72);
    Eigen::VectorXd shapeParams_ = Eigen::VectorXd::Zero(10);

public:
    SMPLModel() = default;

    // Getters
    const Eigen::MatrixXd &getTemplateVertices() const
    {
        return templateVertices_;
    }
    const Eigen::MatrixXd &getShapeBlendShapes() const
    {
        return shapeBlendShapes_;
    }
    const Eigen::MatrixXd &getPoseBlendShapes() const { return poseBlendShapes_; }
    const Eigen::MatrixXd &getJointRegressor() const { return jointRegressor_; }
    const Eigen::MatrixXd &getWeights() const { return weights_; }
    const Eigen::MatrixXi &getKinematicTree() const { return kinematicTree_; }
    const Eigen::MatrixXi &getFaces() const { return faces_; }

    // Load SMPL model parameters from JSON file generated by preprocess.py.
    //
    // Expected keys in the JSON (see preprocess.py):
    //   - "vertices_template"  : (6890, 3)
    //   - "face_indices"       : (F, 3)
    //   - "shape_blend_shapes" : (6890, 3, 10)
    //   - "pose_blend_shapes"  : (6890, 3, 207)
    //   - "joint_regressor"    : (24, 6890)
    //   - "weights"            : (6890, 24)
    //   - "kinematic_tree"     : (2, 24)
    bool loadFromJson(const std::string &jsonPath);

    // Set SMPL pose parameters (e.g. 72 axis-angle parameters).
    void setPose(const std::vector<double> &poseParams);

    // Set SMPL shape parameters (e.g. 10 betas).
    void setShape(const std::vector<double> &shapeParams);

    // Get mesh based on pose and shape parameters.
    SMPLMesh computeMesh() const;

    // Get 3D joints based on pose and shape parameters
    Eigen::MatrixXd getJointPositions() const;

    // rodrigues: axis-angle vector â†’ rotation matrix
    // Implemented with template so it works with Ceres
    // We use fixed size types for performance reasons, otherwise that ceres optimization takes forever.
    template <typename T>
    static Eigen::Matrix<T, 3, 3> rodrigues(const Eigen::Matrix<T, 3, 1> &r)
    {
        using std::cos;
        using std::sin;
        using std::sqrt;

        T theta = sqrt(r.squaredNorm() + T(1e-12));
        T c = cos(theta);
        T s = sin(theta);
        T t = T(1.0) - c;

        Eigen::Matrix<T, 3, 1> k = r / theta;

        Eigen::Matrix<T, 3, 3> K;
        K << T(0), -k(2), k(1), k(2), T(0), -k(0), -k(1), k(0), T(0);

        return Eigen::Matrix<T, 3, 3>::Identity() * c + t * k * k.transpose() +
               s * K;
    }

    // computeJoints: compute joint locations from vertices
    // Implemented with template so it works with Ceres
    template <typename T>
    static Eigen::Matrix<T, Eigen::Dynamic, 3> computeJoints(
        const Eigen::MatrixXd &jointRegressor,
        const Eigen::Matrix<T, Eigen::Dynamic, 3> &vertices)
    {
        int numJoints = static_cast<int>(jointRegressor.rows());
        Eigen::Matrix<T, Eigen::Dynamic, 3> J(numJoints, 3);

        for (int j = 0; j < numJoints; ++j)
        {
            for (int c = 0; c < 3; ++c)
            {
                J(j, c) = T(0);
                for (int v = 0; v < jointRegressor.cols(); ++v)
                {
                    J(j, c) += T(jointRegressor(j, v)) * vertices(v, c);
                }
            }
        }
        return J;
    }

    // forwardKinematics: Compute posed joint positions from rest-pose joints
    // Implemented with template so it works with Ceres.
    // We use fixed size types for performance reasons, otherwise that ceres optimization takes forever.
    template <typename T>
    static Eigen::Matrix<T, 24, 3> forwardKinematics(
        const Eigen::Matrix<T, 72, 1> &poseParams,
        const Eigen::Matrix<double, 24, 3> &J_rest,
        const Eigen::VectorXi &parents)
    {
        constexpr int numJoints = 24;

        // Build rotation matrices from axis-angle parameters
        Eigen::Matrix<T, 3, 3> rotations[numJoints];
        for (int j = 0; j < numJoints; ++j)
        {
            Eigen::Matrix<T, 3, 1> r;
            r << poseParams(j * 3), poseParams(j * 3 + 1), poseParams(j * 3 + 2);
            rotations[j] = rodrigues<T>(r);
        }

        // Forward kinematics
        Eigen::Matrix<T, 3, 3> G_rot[numJoints];
        Eigen::Matrix<T, 3, 1> G_trans[numJoints];

        // Root joint
        G_rot[0] = rotations[0];
        G_trans[0] << T(J_rest(0, 0)), T(J_rest(0, 1)), T(J_rest(0, 2));

        // Process children
        for (int j = 1; j < numJoints; ++j)
        {
            int p = parents(j);
            Eigen::Matrix<T, 3, 1> localT;
            localT << T(J_rest(j, 0) - J_rest(p, 0)),
                T(J_rest(j, 1) - J_rest(p, 1)),
                T(J_rest(j, 2) - J_rest(p, 2));
            G_rot[j] = G_rot[p] * rotations[j];
            G_trans[j] = G_trans[p] + G_rot[p] * localT;
        }

        // Return joint positions
        Eigen::Matrix<T, 24, 3> jointPositions;
        for (int j = 0; j < numJoints; ++j)
        {
            jointPositions.row(j) = G_trans[j].transpose();
        }

        return jointPositions;
    }
};