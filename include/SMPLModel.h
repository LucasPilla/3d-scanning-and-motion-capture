// SMPLModel
// ----------
// Interface for the SMPL (Skinned Multi-Person Linear) parametric body model.
// Responsibilities:
//  - Load SMPL model data (shape blend shapes, pose blend shapes, joint regressor)
//  - Convert pose + shape parameters into a 3D mesh
//  - Provide 3D joint locations for optimization
// Used by:
//  - FittingOptimizer
//  - Visualization
// ----------
// NOTE on dependencies:
//  - The implementation in SMPLModel.cpp will use Eigen for linear algebra
//    and 'nlohmann::json' (single-header JSON library) to parse the SMPL
//    JSON file produced by preprocess.py. Make sure that:
//      * Eigen headers are available (Dockerfile already installs libeigen3-dev).
//      * The file 'json.hpp' from nlohmann/json is in your include path,
//        e.g. under 'include/third_party/json.hpp' or 'include/json.hpp'.
//        SMPLModel.cpp will include it as:  #include <nlohmann/json.hpp>

#pragma once

#include <vector>
#include <string>

#include <Eigen/Dense>

// A simple mesh container for SMPL output.
//
// NOTE: We use Eigen types here because later optimization code will
//       operate heavily on matrices/vectors. Visualization code can
//       convert these to OpenCV or other formats when needed.
struct SMPLMesh
{
    std::vector<Eigen::Vector3f> vertices; // size: numVertices, positions in world or model space
    std::vector<Eigen::Vector3i> faces;    // size: numFaces, triangle vertex indices
};

class SMPLModel
{
public:
    SMPLModel() = default;

    // Load SMPL model parameters from a JSON file generated by preprocess.py.
    //
    // Expected keys in the JSON (see preprocess.py):
    //   - "vertices_template"  : (6890, 3)
    //   - "face_indices"       : (F, 3)
    //   - "shape_blend_shapes" : (6890, 3, 10)
    //   - "pose_blend_shapes"  : (6890, 3, 207)
    //   - "joint_regressor"    : (24, 6890)
    //   - "weights"            : (6890, 24)          [may be used later]
    //   - "kinematic_tree"     : (2, 24)             [may be used later]
    //
    // Returns true on success, false on failure.
    bool loadFromJson(const std::string& jsonPath);

    // Set SMPL pose parameters (e.g. 72 axis-angle parameters).
    //
    // For this week, these values are stored but NOT yet used to deform the mesh.
    void setPose(const std::vector<double>& poseParams);

    // Set SMPL shape parameters (e.g. 10 betas).
    //
    // For this week, these values are stored but NOT yet used to deform the mesh.
    void setShape(const std::vector<double>& shapeParams);

    // Get the current mesh.
    //
    // For first week:
    //   - This will simply return the template mesh (no pose/shape deformation yet).
    //   - Later, it will apply shape & pose blendshapes and skinning.
    SMPLMesh getMesh() const;

    // Simple status helper.
    bool isLoaded() const { return loaded_; }

private:
    using MatrixXf = Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic>;
    using MatrixXi = Eigen::Matrix<int,   Eigen::Dynamic, Eigen::Dynamic>;

    // --------- Model data (loaded from JSON) ---------

    // (numVertices, 3)
    MatrixXf templateVertices_;

    // (numFaces, 3) triangle indices
    MatrixXi faces_;

    // Shape blendshapes, flattened as (numVertices * 3, numShapeCoeffs)
    MatrixXf shapeBlendShapes_;

    // Pose blendshapes, flattened as (numVertices * 3, numPoseCoeffs)
    MatrixXf poseBlendShapes_;

    // Joint regressor: (numJoints, numVertices)
    MatrixXf jointRegressor_;

    MatrixXf weights_;            // (N, 24)
    MatrixXi kinematicTree_;      // (2, 24)
    // --------- Current parameters ---------

    // Current pose & shape parameters (stored only for now).
    Eigen::VectorXf poseParams_;   // e.g. size 72
    Eigen::VectorXf shapeParams_;  // e.g. size 10

    bool loaded_ = false;

    // --- SMPL internal helpers ---

    // Rodrigues rotation: axis-angle (3,) â†’ rotation matrix (3x3)
    Eigen::Matrix3f rodrigues(const Eigen::Vector3f& r) const;

    // Compute joint locations from vertices
    Eigen::MatrixXf computeJoints(const Eigen::MatrixXf& vertices) const;

    // Compute global joint transforms (4x4 matrices)
    std::vector<Eigen::Matrix4f> computeGlobalTransforms(
        const Eigen::MatrixXf& J,
        const std::vector<Eigen::Matrix3f>& rotations
    ) const;

};