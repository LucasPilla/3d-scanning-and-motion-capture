// SMPLModel.h
// ----------
// Interface for the SMPL (Skinned Multi-Person Linear) parametric body model.

#pragma once

#include <Eigen/Dense>
#include <string>
#include <vector>
#include <filesystem>

// A simple mesh container for SMPL output.
struct SMPLMesh
{
	// (numVertices, 3)
	std::vector<Eigen::Vector3f> vertices;

	// (numFaces, 3)
	std::vector<Eigen::Vector3i> faces;

	// Saves the mesh to OBJ format
	bool save(const std::filesystem::path path) const;
};

class SMPLModel
{
private:
	using MatrixXd = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>;
	using MatrixXi = Eigen::Matrix<int, Eigen::Dynamic, Eigen::Dynamic>;

	// --------- Model data ---------

	// (numVertices, 3)
	MatrixXd templateVertices_;

	// (numFaces, 3) triangle indices
	MatrixXi faces_;

	// Shape blendshapes, flattened as (numVertices * 3, numShapeCoeffs)
	MatrixXd shapeBlendShapes_;

	// Pose blendshapes, flattened as (numVertices * 3, numPoseCoeffs)
	MatrixXd poseBlendShapes_;

	// Joint regressor: (numJoints, numVertices)
	MatrixXd jointRegressor_;

	// OpenPose Joint regressor: (25, numVertices)
	MatrixXd openPoseJointRegressor_;

	// Weights: (numVertices, numJoints)
	MatrixXd weights_;

	// Kinematic Tree: (2, numJoints)
	MatrixXi kinematicTree_;

	// GMM Prior Data
	MatrixXd gmmMeans_;
	std::vector<Eigen::MatrixXd> gmmPrecChols_;
	MatrixXd gmmWeights_;
	Eigen::VectorXd gmmMeanPose_;

	// // Capsule Regressors
	// MatrixXd capsuleV2Lens_;	 // Base lengths
	// MatrixXd capsuleBetas2Lens_; // Linear weights (shape -> lengths)
	// MatrixXd capsuleV2Rads_;	 // Base radius
	// MatrixXd capsuleBetas2Rads_; // Linear weights (shape -> radius)

	// Precomputed for optimization (SMPL joints)
	Eigen::MatrixXd J_mean_;
	std::vector<Eigen::MatrixXd> J_dirs_;

	// Precomputed for optimization (OpenPose joints)
	Eigen::MatrixXd openposeJ_mean_;
	std::vector<Eigen::MatrixXd> openposeJ_dirs_;

	// --------- Parameters ---------

	// Pose parameters (72 axis-angle parameters)
	Eigen::VectorXd poseParams_ = Eigen::VectorXd::Zero(72);

	// Shape parameters (10 betas)
	Eigen::VectorXd shapeParams_ = Eigen::VectorXd::Zero(10);

public:
	SMPLModel() = default;

	// Getters
	const Eigen::VectorXd &getPoseParams() const { return poseParams_; }
	const Eigen::VectorXd &getShapeParams() const { return shapeParams_; }
	const Eigen::MatrixXd &getGmmMeans() const { return gmmMeans_; }
	const std::vector<Eigen::MatrixXd> &getGmmPrecChols() const { return gmmPrecChols_; }
	const Eigen::MatrixXd &getGmmWeights() const { return gmmWeights_; }
	const Eigen::VectorXd getGmmMeanPose() const { return gmmMeanPose_; }

	// Load SMPL model parameters from JSON file generated by preprocess.py.
	//
	// Expected keys in the JSON (see preprocess.py):
	//   - "vertices_template"        : (6890, 3)
	//   - "face_indices"             : (F, 3)
	//   - "shape_blend_shapes"       : (6890, 3, 10)
	//   - "pose_blend_shapes"        : (6890, 3, 207)
	//   - "joint_regressor"          : (24, 6890)
	//   - "openpose_joint_regressor" : (25, 6890)
	//   - "weights"                  : (6890, 24)
	//   - "kinematic_tree"           : (2, 24)
	//   - "gmm_means" 			      : (8, 69)
	//   - "gmm_covars" 		      : (8, 69, 69)
	//   - "gmm_weights" 		      : (8)
	//   - "capsule_v2lens" 	  	(not used)
	//   - "capsule_betas2lens" 	(not used)
	//   - "capsule_v2rads" 	  	(not used)
	//   - "capsule_betas2rads" 	(not used)
	bool loadFromJson(const std::string &jsonPath);

	// Set SMPL pose parameters (e.g. 72 axis-angle parameters).
	void setPose(const Eigen::VectorXd &poseParams);

	// Set SMPL shape parameters (e.g. 10 betas).
	void setShape(const Eigen::VectorXd &shapeParams);

	// Get mesh based on pose and shape parameters.
	SMPLMesh computeMesh();

	// rodrigues: Axis-angle vector â†’ rotation matrix
	template <typename T>
	static Eigen::Matrix<T, 3, 3> rodrigues(const Eigen::Matrix<T, 3, 1> &r)
	{
		using std::cos;
		using std::sin;
		using std::sqrt;

		T theta = sqrt(r.squaredNorm() + T(1e-12));
		T c = cos(theta);
		T s = sin(theta);
		T t = T(1.0) - c;

		Eigen::Matrix<T, 3, 1> k = r / theta;

		Eigen::Matrix<T, 3, 3> K;
		K << T(0), -k(2), k(1), k(2), T(0), -k(0), -k(1), k(0), T(0);

		return Eigen::Matrix<T, 3, 3>::Identity() * c + t * k * k.transpose() +
			   s * K;
	}

	template <typename T>
	Eigen::Matrix<T, 24, 3> regressSmplRestJoints(const Eigen::Matrix<T, 10, 1>& shapeParams) const 
	{
		// Use the precomputed J_mean and J_dirs
		Eigen::Matrix<T, 24, 3> restJoints = J_mean_.cast<T>();
		for (int k = 0; k < 10; ++k) {
			restJoints += J_dirs_[k].cast<T>() * shapeParams(k);
		}
		return restJoints;
	}

	template <typename T>
	Eigen::Matrix<T, 25, 3> regressOpenposeRestJoints(const Eigen::Matrix<T, 10, 1>& shapeParams) const 
	{
		// Use the precomputed J_mean and J_dirs
		Eigen::Matrix<T, 25, 3> restJoints = openposeJ_mean_.cast<T>();
		for (int k = 0; k < 10; ++k) {
			restJoints += openposeJ_dirs_[k].cast<T>() * shapeParams(k);
		}
		return restJoints;
	}

	// Result struct for computeWorldTransforms
	template <typename T>
	struct JointTransforms
	{
		Eigen::Matrix<T, 3, 3> rotations[24]; // Per-joint rotation matrices
		Eigen::Matrix<T, 3, 3> G_rot[24];	  // Global rotation transforms
		Eigen::Matrix<T, 3, 1> G_trans[24];	  // Global translation transforms
	};

	template <typename T>
	JointTransforms<T> computeWorldTransforms(
		const Eigen::Matrix<T, 72, 1>& poseParams,
		const Eigen::Matrix<T, 24, 3>& restJoints) const 
	{
		JointTransforms<T> result;
		Eigen::VectorXi parents = kinematicTree_.row(0);

		for (int j = 0; j < 24; ++j) {
			Eigen::Matrix<T, 3, 1> r = poseParams.segment(j * 3, 3);
			result.rotations[j] = rodrigues<T>(r);
		}

		// Root joint
		result.G_rot[0] = result.rotations[0];
		result.G_trans[0] = restJoints.row(0).transpose();

		// Kinematic Tree
		for (int j = 1; j < 24; ++j) {
			int p = parents(j);
			Eigen::Matrix<T, 3, 1> localT = restJoints.row(j).transpose() - restJoints.row(p).transpose();
			
			result.G_rot[j] = result.G_rot[p] * result.rotations[j];
			result.G_trans[j] = result.G_trans[p] + result.G_rot[p] * localT;
		}

		return result;
	}
};