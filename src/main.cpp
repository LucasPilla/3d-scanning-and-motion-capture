// main.cpp
// ---------
// Pipeline entry point.
// This only orchestrates the modules; all logic lives in separate classes.
// Steps:
//  1) Load video frames (VideoLoader)
//  2) Extract 2D joints using OpenPose (PoseDetector)
//  3) Fit SMPL to each frame (FittingOptimizer)
//  4) Visualize or export results (Visualization)

#include "VideoLoader.h"
#include "PoseDetector.h"
#include "Visualization.h"
#include "FittingOptimizer.h"
#include "TemporalSmoother.h"
#include "SMPLModel.h" 
#include "CameraModel.h"

#include <argparse/argparse.hpp>
#include <iostream>
#include <filesystem>
#include <Eigen/Dense>

int main(int argc, char* argv[])
{

    argparse::ArgumentParser program("pipeline");

    // Pipeline requires a video path
    program.add_argument("--video-path")
        .help("Path to video file")
        .required();

    // Pipeline requires a SMPL model path
    program.add_argument("--smpl-path")
        .help("Path to model generated by preprocess.py (.json)")
        .required();

    // Optional path to output folder
    // Default is "./output"
    program.add_argument("--output")
        .help("Output folder to save results.")
        .default_value("./output");

    // Optional path to pre-computed keypoints
    // If not defined, OpenPose will run for each frame
    program.add_argument("--precomputed-keypoints")
        .help("Path to pre-computed keypoints (.json)");

    // Optional: process only a single frame and save debug images
    program.add_argument("--debug-frame")
    .help("If set, process only this 1-based frame index and save debug images")
    .scan<'i', int>();

    try {
        // Parse args
        program.parse_args(argc, argv);
    }
    catch (const std::runtime_error& err) {
        // This block runs if the user forgets the argument
        std::cerr << err.what() << std::endl;
        std::cerr << program;
        std::exit(1);
    }

    // Load command line arguments into variables
    std::string videoPath = program.get("--video-path");

    std::string smplPath = program.get("--smpl-path");

    std::filesystem::path outputFolder = program.get("--output");

    std::optional<std::string> precomputedKeypointsPath = std::nullopt;
    if (program.is_used("--precomputed-keypoints"))
        precomputedKeypointsPath = program.get("--precomputed-keypoints");

    std::optional<int> debugFrame = std::nullopt;
    if (program.is_used("--debug-frame")) 
        debugFrame = program.get<int>("--debug-frame");

    // Create output folder
    std::filesystem::create_directory(outputFolder);

    // Initialize video loader
    VideoLoader loader(videoPath);

    // Initialize pose detector
    PoseDetector poseDetector(precomputedKeypointsPath);

    // Initialize output video writer
    Visualization visualizer(loader.width(), loader.height(), loader.fps());

    // Initialize simple pinhole camera intrinsics (approximate)
    float fx = static_cast<float>(loader.width());
    float fy = static_cast<float>(loader.width()); // assume square pixels, fx ~ fy
    float cx = fx / 2.0f;
    float cy = static_cast<float>(loader.height()) / 2.0f;
    CameraModel camera(fx, fy, cx, cy);

    // Load SMPL model (preprocessed JSON).
    SMPLModel smplModel;
    if (!smplModel.loadFromJson(smplPath)) {
        std::cerr << "Warning: Failed to load SMPL model from " << smplPath << std::endl;
    }

    // Configure optimizer fitting options (flags).
    FittingOptimizer::Options fitOpts;
    fitOpts.temporalRegularization = true;
    fitOpts.warmStarting           = false;
    fitOpts.freezeShapeParameters  = false;

    // Initialize optimizer using SMPLModel instance
    FittingOptimizer fitter(&smplModel, fitOpts);

    int frameIdx = 0;
    cv::Mat frame;

    while (loader.readFrame(frame)) {

        frameIdx++;

        // // During initial development let's work with a small range of frames.
        // int startFrame = 1;
        // int endFrame   = 100;

        // if (frameCounter < startFrame) continue;
        // if (frameCounter >= endFrame) break;

        std::cout << "Processing frame " << frameIdx << "\n";

        // if debug-frame is set, skip frames before it and stop after it
        if (debugFrame.has_value()) {
            if (frameIdx < *debugFrame) {
                continue; 
            }
            if (frameIdx > *debugFrame) {
                break;    
            }
        }

        // keep a copy of the raw input frame for debug visualization
        cv::Mat frameInput = frame.clone();

        // Extract pose
        Pose2D pose2D = poseDetector.detect(frame, frameIdx);

        // Run optimizer (currently a stub, just prepares data)
        fitter.fitFrame(pose2D);

        // Trigger SMPL forward pass once per frame with the current params
        SMPLMesh mesh = smplModel.getMesh();

        // Project SMPL joints to image using the camera model (debug visualization)
        Eigen::MatrixXf joints3D = smplModel.getJointPositions();

        // BODY_25 index for MidHip in OpenPose
        const int MID_HIP_2D = 8;
        const int ROOT_3D = 0; // SMPL root joint index

        bool canAlignRoot =
            joints3D.rows() > ROOT_3D &&
            pose2D.keypoints.size() > MID_HIP_2D &&
            pose2D.keypoints[MID_HIP_2D].score > 0.1f;

        Eigen::Vector3f offset = Eigen::Vector3f::Zero();

        if (canAlignRoot) {
            // 2D pelvis from OpenPose
            Point2D root2D = pose2D.keypoints[MID_HIP_2D];

            // Choose a nominal depth (meters) for the person
            float z0 = 3.0f;

            // Desired camera-space position of pelvis
            Eigen::Vector3f rootCam(
                (root2D.x - cx) / fx * z0,
                (root2D.y - cy) / fy * z0,
                z0
            );

            // Current SMPL root in model space
            Eigen::Vector3f smplRoot(
                joints3D(ROOT_3D, 0),
                joints3D(ROOT_3D, 1),
                joints3D(ROOT_3D, 2)
            );

            // Translation that maps SMPL root to desired camera position
            offset = rootCam - smplRoot;
        }

        // build camera-space joints and initial 2D projection ("before")
        Eigen::MatrixXf jointsCam(joints3D.rows(), 3);
        std::vector<Point2D> smplProjected(joints3D.rows());

        for (int i = 0; i < joints3D.rows(); ++i) {
            Eigen::Vector3f pWorld(
                joints3D(i, 0),
                joints3D(i, 1),
                joints3D(i, 2)
            );
        
            // apply global translation so root matches OpenPose pelvis
            Eigen::Vector3f pCam = pWorld + offset;
            jointsCam.row(i) = pCam.transpose();
        
            Point2D pt; // defaults to zeros
            if (pCam.z() > 0.0f) {
                Eigen::Vector2f p2D = camera.project(pCam);
                pt.x = p2D.x();
                pt.y = p2D.y();
                pt.score = 1.0f;
            }
        
            smplProjected[i] = pt;
        }

        // optimize a global 3D rigid transform in camera space (single-frame debug)
        std::vector<Point2D> smplProjectedOptimized;
        fitter.fitRigid3D(jointsCam, fx, fy, cx, cy, smplProjectedOptimized);

        // debug: inspect SMPL 2D projections
        if (debugFrame.has_value() && frameIdx == *debugFrame) {
            int validBefore = 0, validAfter = 0;
            int inFrameBefore = 0, inFrameAfter = 0;
        
            int W = frame.cols;
            int H = frame.rows;
        
            for (size_t i = 0; i < smplProjected.size(); ++i) {
                const auto& pB = smplProjected[i];
                const auto& pA = smplProjectedOptimized[i];
        
                if (pB.x > 0.0f && pB.y > 0.0f) {
                    ++validBefore;
                    if (pB.x < W && pB.y < H) ++inFrameBefore;
                }
                if (pA.x > 0.0f && pA.y > 0.0f) {
                    ++validAfter;
                    if (pA.x < W && pA.y < H) ++inFrameAfter;
                }
            }
        
            std::cout << "[Debug] Frame " << frameIdx
                      << " SMPL valid before/after: " << validBefore << "/" << validAfter
                      << ", in-frame before/after: " << inFrameBefore << "/" << inFrameAfter
                      << std::endl;
        }

        // at this point we have:
        //  frameInput: raw frame
        //  pose2D: OpenPose joints
        //  smplProjected: projected SMPL joints
        if (debugFrame.has_value() && frameIdx == *debugFrame) {
            std::string frameId = std::to_string(frameIdx);
        
            // raw input image
            std::filesystem::path inputPath =
                outputFolder / ("frame_" + frameId + "_input.png");
            cv::imwrite(inputPath.string(), frameInput);
        
            // input + OpenPose keypoints
            cv::Mat frameKeypoints = frameInput.clone();
            visualizer.drawKeypoints(frameKeypoints, pose2D.keypoints);
            std::filesystem::path keypointsPath =
                outputFolder / ("frame_" + frameId + "_keypoints.png");
            cv::imwrite(keypointsPath.string(), frameKeypoints);
        
            // input + OpenPose keypoints + SMPL BEFORE optimization (blue)
            cv::Mat frameSmplBefore = frameKeypoints.clone();
            visualizer.drawJoints(frameSmplBefore, smplProjected, cv::Scalar(255, 0, 0), 3);
            std::filesystem::path smplBeforePath =
                outputFolder / ("frame_" + frameId + "_smpl_before.png");
            cv::imwrite(smplBeforePath.string(), frameSmplBefore);
        
            // input + OpenPose keypoints + SMPL AFTER rigid optimization (yellow)
            cv::Mat frameSmplAfter = frameKeypoints.clone();
            visualizer.drawJoints(frameSmplAfter, smplProjectedOptimized, cv::Scalar(0, 255, 255), 3);
            std::filesystem::path smplAfterPath =
                outputFolder / ("frame_" + frameId + "_smpl_after.png");
            cv::imwrite(smplAfterPath.string(), frameSmplAfter);

            // SMPL BEFORE only (no keypoints), big blue dots
            cv::Mat frameSmplOnlyBefore = frameInput.clone();
            visualizer.drawJoints(frameSmplOnlyBefore, smplProjected, cv::Scalar(255, 0, 0), 8);
            std::filesystem::path smplOnlyBeforePath =
                outputFolder / ("frame_" + frameId + "_smpl_only_before.png");
            cv::imwrite(smplOnlyBeforePath.string(), frameSmplOnlyBefore);

            // SMPL AFTER only (no keypoints), big yellow dots
            cv::Mat frameSmplOnlyAfter = frameInput.clone();
            visualizer.drawJoints(frameSmplOnlyAfter, smplProjectedOptimized, cv::Scalar(0, 255, 255), 8);
            std::filesystem::path smplOnlyAfterPath =
                outputFolder / ("frame_" + frameId + "_smpl_only_after.png");
            cv::imwrite(smplOnlyAfterPath.string(), frameSmplOnlyAfter);
        }

        // // Save mesh
        // std::ostringstream meshFilename;
        // meshFilename << std::setw(6) << std::setfill('0') << frameIdx << ".obj";
        // std::filesystem::path meshPath = outputFolder / meshFilename.str();
        // mesh.save(meshPath);
    
        // draw OpenPose BODY_25 skeleton
        visualizer.drawKeypoints(frame, pose2D.keypoints);
        // draw SMPL projected joints in a distinct color
        visualizer.drawJoints(frame, smplProjected, cv::Scalar(255, 0, 0), 3);
        // write the frame
        visualizer.write(frame);

        if (debugFrame.has_value() && frameIdx == *debugFrame) {
            break;
        }
    }

    std::cout << "Output written to output.mp4\n";

    return 0;
}