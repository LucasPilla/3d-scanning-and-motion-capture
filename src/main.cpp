// main.cpp
// ---------
// Pipeline entry point.
// This only orchestrates the modules; all logic lives in separate classes.
// Steps:
//  1) Load video frames (VideoLoader)
//  2) Extract 2D joints using OpenPose (PoseDetector)
//  3) Fit SMPL to each frame (SMPLOptimizer)
//  4) Visualize or export results (Visualization)

#include "CameraModel.h"
#include "SMPLOptimizer.h"
#include "PoseDetector.h"
#include "SMPLModel.h"
#include "TemporalSmoother.h"
#include "VideoLoader.h"
#include "Visualization.h"

#include <Eigen/Dense>
#include <argparse/argparse.hpp>
#include <filesystem>
#include <iostream>

int main(int argc, char *argv[])
{

	argparse::ArgumentParser program("pipeline");

	// Pipeline requires a video path
	program.add_argument("--video-path").help("Path to video file").required();

	// Pipeline requires a SMPL model path
	program.add_argument("--smpl-path")
		.help("Path to model generated by preprocess.py (.json)")
		.required();

	// Optional path to output folder
	// Default is "./output"
	program.add_argument("--output")
		.help("Output folder to save results.")
		.default_value("./output");

	// Optional path to pre-computed keypoints
	// If not defined, OpenPose will run for each frame
	program.add_argument("--precomputed-keypoints")
		.help("Path to pre-computed keypoints (.json)");

	// Optional: process only a single frame and save debug images
	program.add_argument("--debug-frame")
		.help(
			"If set, process only this 1-based frame index and save debug images")
		.scan<'i', int>();

	try
	{
		// Parse args
		program.parse_args(argc, argv);
	}
	catch (const std::runtime_error &err)
	{
		// This block runs if the user forgets the argument
		std::cerr << err.what() << std::endl;
		std::cerr << program;
		std::exit(1);
	}

	// Load command line arguments into variables
	std::string videoPath = program.get("--video-path");

	std::string smplPath = program.get("--smpl-path");

	std::filesystem::path outputFolder = program.get("--output");

	std::optional<std::string> precomputedKeypointsPath = std::nullopt;
	if (program.is_used("--precomputed-keypoints"))
		precomputedKeypointsPath = program.get("--precomputed-keypoints");

	std::optional<int> debugFrame = std::nullopt;
	if (program.is_used("--debug-frame"))
		debugFrame = program.get<int>("--debug-frame");

	// Create output folder
	std::filesystem::create_directory(outputFolder);

	// Initialize video loader
	VideoLoader loader(videoPath);

	// Initialize pose detector
	PoseDetector poseDetector(precomputedKeypointsPath);

	// Initialize output video writer
	Visualization visualizer(loader.width(), loader.height(), loader.fps());

	// Initialize simple pinhole camera intrinsics (approximate)
	double fx = static_cast<double>(loader.width());
	double fy = static_cast<double>(loader.width());
	double cx = static_cast<double>(loader.width()) / 2.0f;
	double cy = static_cast<double>(loader.height()) / 2.0f;
	CameraModel cameraModel(fx, fy, cx, cy);

	// Load SMPL model (preprocessed JSON).
	SMPLModel smplModel;
	if (!smplModel.loadFromJson(smplPath))
	{
		std::cerr << "Warning: Failed to load SMPL model from " << smplPath
				  << std::endl;
	}

	// Configure optimizer fitting options (flags).
	SMPLOptimizer::Options fitOpts;
	fitOpts.temporalRegularization = false;
	fitOpts.warmStarting = false;
	fitOpts.freezeShapeParameters = false;

	// Initialize optimizer using SMPLModel instance
	SMPLOptimizer fitter(&smplModel, &cameraModel, fitOpts);

	int frameIdx = 0;
	cv::Mat frame;

	while (loader.readFrame(frame))
	{

		frameIdx++;

		// if debug-frame is set, skip frames before it and stop after it
		if (debugFrame.has_value())
		{
			if (frameIdx < *debugFrame)
			{
				continue;
			}
			if (frameIdx > *debugFrame)
			{
				break;
			}
		}

		std::cout << "Processing frame " << frameIdx << "\n";

		// keep a copy of the raw input frame for debug visualization
		cv::Mat frameInput = frame.clone();

		// Extract pose
		Pose2D pose2D = poseDetector.detect(frame, frameIdx);

		// Run optimizer
		fitter.fitFrame(pose2D);

		// DEBUG
		if (debugFrame.has_value() && frameIdx == *debugFrame)
		{
			std::string frameId = std::to_string(frameIdx);

			// Compute mesh for visualization
			SMPLMesh mesh = smplModel.computeMesh();

			// frame + mesh overlay
			cv::Mat frameMesh = frameInput.clone();
			visualizer.drawMesh(frameMesh, mesh, cameraModel, fitter.getGlobalR(),
								fitter.getGlobalT(), cv::Scalar(0, 255, 255), 1);
			std::filesystem::path meshOverlayPath =
				outputFolder / ("frame_" + frameId + "_mesh_overlay.png");
			cv::imwrite(meshOverlayPath.string(), frameMesh);

			std::cout << "Debug images saved to " << outputFolder << std::endl;
		}
	}

	return 0;
}